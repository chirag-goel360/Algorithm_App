{
  "techniques": [
    {
      "name": "Divide and Conquer",
      "id": 1,
      "description": "",
      "image_url": "https://i.ibb.co/fpzjBpG/DandC.png",
      "data": "A divide-and-conquer algorithm works by recursively breaking down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem."
    },
    {
      "name": "Greedy Method",
      "id": 2,
      "description": "",
      "image_url": "https://i.ibb.co/9WzcBjK/greedy.png",
      "data": "A greedy algorithm, as the name suggests, always makes the choice that seems to be the best at that moment. This means that it makes a locally-optimal choice in the hope that this choice will lead to a globally-optimal solution.\n\n<b>How do you decide which choice is optimal?</b>\n\nAssume that you have an objective function that needs to be optimized (either maximized or minimized) at a given point. A Greedy algorithm makes greedy choices at each step to ensure that the objective function is optimized. The Greedy algorithm has only one shot to compute the optimal solution so that it never goes back and reverses the decision.\n\nGreedy algorithms have some advantages and disadvantages:\n\n 1. It is quite easy to come up with a greedy algorithm (or even multiple greedy algorithms) for a problem.\n\n 2. Analyzing the run time for greedy algorithms will generally be much easier than for other techniques (like Divide and conquer). For the Divide and conquer technique, it is not clear whether the technique is fast or slow. This is because at each level of recursion the size of gets smaller and the number of sub-problems increases.\n\n 3. The difficult part is that for greedy algorithms you have to work much harder to understand correctness issues. Even with the correct algorithm, it is hard to prove why it is correct. Proving that a greedy algorithm is correct is more of an art than a science. It involves a lot of creativity.\nNote: Most greedy algorithms are not correct. An example is described later in this article."
    },
    {
      "name": "Dyanamic Programming",
      "id": 3,
      "description": "",
      "image_url": "https://i.ibb.co/rFMZCVN/dynamic.jpg",
      "data": "Dynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions using a memory-based data structure (array, map,etc). Each of the subproblem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup. So the next time the same subproblem occurs, instead of recomputing its solution, one simply looks up the previously computed solution, thereby saving computation time. This technique of storing solutions to subproblems instead of recomputing them is called memoization.\n\n\nFour Steps of Dynamic Programming \n\n1. Characterize the structure of an optimal solution\n2. Recursively define the value of an optimal solution\n3. Compute the value of an optimal solution\n4. Construct an optimal solution from computed information\n\n\n Elements of dynamic programming\n\nTwo key ingredients that an optimization problem must have in order to apply dynamic programming:\n1. Optimal substructure\n2. Overlapping sub-problems"
    },
    {
      "name": "Branch and Bound",
      "id": 4,
      "description": "",
      "image_url": "https://i.ibb.co/BfWK9LZ/branch-Bound.jpg",
      "data": "Branch and bound is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems are typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. The Branch and Bound Algorithm technique solves these problems relatively quickly."
    },
    {
      "name": "Randomized Algorithms",
      "id": 5,
      "description": "",
      "image_url": "https://i.ibb.co/swXGrzt/random.gif",
      "data": "A randomized algorithm is an algorithm that employs a degree of randomness as part of its logic. The algorithm typically uses uniformly random bits as an auxiliary input to guide its behavior, in the hope of achieving good performance in the \"average case\" over all possible choices of random bits."
    },
    {
      "name": "Backtracking Algorithms",
      "id": 6,
      "description": "",
      "image_url": "https://i.ibb.co/P1kxmtQ/backtracking.png",
      "data": "Backtracking is an algorithmic-technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point of time"
    }
  ]
}